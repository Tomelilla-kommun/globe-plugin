/**
 * This code defines a custom Origo UI component called "Globe". It creates a 3D globe using CesiumJS and integrates it into an Origo map.
 * The component provides various configuration options for the globe, such as terrain providers, 3D tile providers, and globe settings.
 * It also includes functionality for picking features on the globe and displaying feature information in a popup.
 * Additionally, it includes buttons for toggling the globe on/off and opening a datetime picker.
 */
// @ts-ignore: Suppress module not found error if types are missing
import OLCesium from 'olcs/OLCesium';
// @ts-ignore: Suppress module not found error if types are missing
import Origo from 'Origo';
import flatpickr from 'flatpickr';
import * as Cesium from 'cesium';
import {
  Ion,
  IonResource,
  createWorldTerrainAsync,
  CesiumTerrainProvider,
  ScreenSpaceEventHandler,
  PostProcessStageLibrary,
  ScreenSpaceEventType,
  Color,
  SkyBox,
  JulianDate,
  Clock
} from 'cesium';
import isGlobeActive from './functions/isglobeactive';
import addGLTF from './layer/gltf';
import add3DTile from './layer/threedtile';
import { threedtile } from './layer/layerhelper';
import getFeatureInfo from './functions/featureinfo'
import SensorShadow from './functions/SensorShadow'

window.Cesium = Cesium;
window.OLCesium = OLCesium;

declare global {
  interface Window {
    Cesium: typeof Cesium;
    OLCesium: typeof OLCesium;
    oGlobe?: any;
  }
}

window.Cesium = Cesium;

  interface GlobeButton extends Origo.ui.Button {}
  interface GlobeOptions {
    target?: string;
    globeOnStart?: boolean;
    showGlobe?: boolean;
    resolutionScale?: number;
    settings?: Record<string, any>;
    cesiumTerrainProvider?: string;
    cesiumIontoken?: string;
    cesiumIonassetIdTerrain?: number;
    cesium3DTileUrl?: string;
    gltf?: Array<{
      url: string;
      lat: number;
      lng: number;
      height: number;
      heightReference?: any;
      animation?: any;
    }>;
    deactivateControls?: string[];
  }
  // interface GlobeHelpers {
  //   activeGlobeOnStart: () => void;
  //   showGlobeOption: () => void;
  //   cesiumCredits: () => void;
  //   setActiveControls: (getGlobe: any, v: any) => void;
  //   timeSetter: () => void;
  //   pickedFeatureStyle: () => void;
  //   flyTo: (destination: any, duration: any, orientation?: any) => void;
  //   setView: (destination: any, duration: any, orientation?: any) => void;
  //   addSvgIcons: () => void;
  //   addStreetView: () => void;
  //   addControls: () => void;
  // }
  // interface GlobeAssets {
  //   terrainProviders: () => Promise<void>;
  //   cesium3DtilesProviders: () => void;
  //   gltfProviders: () => void;
  // }
  // interface CesiumSettings {
  //   scene: () => void;
  //   globe: () => void;
  // }

  var globeButton: Origo.ui.Button;
  var globeEl: Origo.ui.Element;

export const Globe = function Globe(options: GlobeOptions = {}) {
  let {
    target = undefined
  } = options;

  const {
    globeOnStart,
    showGlobe = true,
    resolutionScale = window.devicePixelRatio,
    settings = {},
    cesiumTerrainProvider,
    cesiumIontoken,
    cesiumIonassetIdTerrain,
    gltf,
    deactivateControls = []
  } = options;

  let map: any;
  let viewer: any;
  let oGlobe: any;
  let oGlobeTarget: string | undefined;
  let terrain: Cesium.CesiumTerrainProvider | undefined;
  let featureInfo: any;
  // let globeEl: Origo.ui.Element;
  // let globeButton: Origo.ui.Button;
  let fp: flatpickr.Instance;
  let flatpickrEl: Origo.ui.Element;
  let flatpickrButton: Origo.ui.Button;
  let viewshedButton: Origo.ui.Button;
  let toggleShadowsButton: Origo.ui.Button;
  let quickTimePickerButton: Origo.ui.Button;
  let toggleFXButton: Origo.ui.Button;
  let scene: Cesium.Scene;
  let htmlString: string;
  let el: HTMLElement;
  let cameraHeight = 1.6;
  let streetModeHandler: Cesium.ScreenSpaceEventHandler | null;
  let streetModePostRenderCallback: (() => void) | null;
  let isStreetMode = false;
  let isCameraAnimating = false;
  let isViewShed = false;
  let isDragging = false;
  let lastMousePosition: Cesium.Cartesian2 | undefined;

  const flags = {
    looking: false,
    moveForward: false,
    moveBackward: false,
    moveUp: false,
    moveDown: false,
    moveLeft: false,
    moveRight: false
  };

  const keys = {
    KeyW: 'moveForward',
    KeyS: 'moveBackward',
    KeyA: 'moveLeft',
    KeyD: 'moveRight',
    KeyQ: 'moveUp',
    KeyE: 'moveDown',
  };

  const buttons: GlobeButton[] = [];

  // To use Cesium Ion features token needs to be provided in config option "token"
  if (cesiumIontoken) {
    Ion.defaultAccessToken = cesiumIontoken;
  }

  // Toggles between 2D and 3D
  const toggleGlobe = () => {
    // Check if map projection is EPSG:4326 or EPSG:3857.
    // If map has other projection, don't activate globe and log error
    if (viewer.getProjectionCode() === 'EPSG:4326' || viewer.getProjectionCode() === 'EPSG:3857') {
      oGlobe.setEnabled(!isGlobeActive(oGlobe));
      const streetView = document.getElementById('streetView');
      const controlUI = document.getElementById('controlUI');
      if(streetView && controlUI) {
        streetView.style.display = !isGlobeActive(oGlobe) ? 'none' : 'flex';
        controlUI.style.display = !isGlobeActive(oGlobe) ? 'none' : 'flex';
      }
    } else {
      console.error('Map projection must be EPSG:4326 or EPSG:3857 to be able to use globe mode.');
    }
  };

  // Toggles subbuttons to globe button
  const toggleButtons = () => {
    const globeButtonEl = document.getElementById(globeButton.getId());
    if (globeButtonEl) {
      globeButtonEl.classList.toggle('active');
    }

    const flatpickrButtonEl = document.getElementById(flatpickrButton.getId());
    const viewshedButtonEL = document.getElementById(viewshedButton.getId());
    const toggleShadowsButtonEl = document.getElementById(toggleShadowsButton.getId());
    const quickTimePickerButtonEl = document.getElementById(quickTimePickerButton.getId());
    const isActive = globeButtonEl ? globeButtonEl.classList.contains('active') : false;
    const toggleFXButtonEl = document.getElementById(toggleFXButton.getId());

    if (flatpickrButtonEl) flatpickrButtonEl.classList.toggle('hidden', !isActive);
    if (viewshedButtonEL) viewshedButtonEL.classList.toggle('hidden', !isActive);
    if (toggleShadowsButtonEl) toggleShadowsButtonEl.classList.toggle('hidden', !isActive);
    if (quickTimePickerButtonEl) quickTimePickerButtonEl.classList.toggle('hidden', !isActive);
    if (toggleFXButtonEl) toggleFXButtonEl.classList.toggle('hidden', !isActive);
  };

  const helpers = {
    // Init map with globe or not
    activeGlobeOnStart: () => {
      if (globeOnStart) {
        toggleGlobe();
        toggleButtons();
      }
    },
    // Renders the globe or not, only effects the terrain and raster overlays on it
    showGlobeOption: () => {
      if (!showGlobe) {
        scene.globe.show = false;
      }
    },
    // Hides Cesium credit container. Put the cesium credits in origo credits container in origo style
    cesiumCredits: () => {
      const creditLogoContainers = document.querySelectorAll('.cesium-credit-logoContainer');
      if (creditLogoContainers.length > 0 && creditLogoContainers[0].parentNode) {
        (creditLogoContainers[0].parentNode as HTMLElement).style.display = 'none';
      }
    },
    // Helper to hide/unhide Origo controls that has no effect in globe mode
    setActiveControls: (
      getGlobe: any,
      v: {
      getControlByName: (name: string) => Origo.ui.Control | undefined;
      }
    ) => {
      interface OrigoControl {
      hide: () => void;
      unhide: () => void;
      }

      deactivateControls.forEach((deactivateControl: string) => {
      const control = v.getControlByName(deactivateControl) as OrigoControl | undefined;
      if (!control) {
        console.error(`No control named "${deactivateControl}" to hide/unhide for globe control`);
        return;
      }
      if (isGlobeActive(getGlobe)) {
        control.hide();
      } else {
        control.unhide();
      }
      });
    },
    // Date and time picker from flatpickr
    timeSetter() {
      flatpickrEl = Origo.ui.Element({
        tagName: 'div',
        cls: 'flatpickrEl z-index-ontop-top-times20'
      });

      htmlString = flatpickrEl.render();
      el = Origo.ui.dom.html(htmlString);
      const parentEl = document.getElementById(target ?? '');
      if (parentEl) {
        parentEl.appendChild(el);
      } else {
        console.error(`Element with id "${target}" not found.`);
      }
      const flatpickrElement = document.getElementById(flatpickrEl.getId());
      if (flatpickrElement) {
        fp = flatpickr(flatpickrElement, {
          enableTime: true,
          defaultDate: new Date(),
          enableSeconds: true,
          disableMobile: false,
          time_24hr: true
        });
      } else {
        console.error('Flatpickr element not found');
      }
    },
    // Origo style on picked feature
    pickedFeatureStyle: () => {
      const handler = new ScreenSpaceEventHandler(scene.canvas);
      if (PostProcessStageLibrary.isSilhouetteSupported(scene)) {
        const silhouetteBlue = PostProcessStageLibrary.createEdgeDetectionStage();
        silhouetteBlue.uniforms.color = Color.ROYALBLUE;
        silhouetteBlue.uniforms.length = 0.01;
        silhouetteBlue.selected = [];

        scene.postProcessStages.add(
          PostProcessStageLibrary.createSilhouetteStage([
            silhouetteBlue
          ])
        );
        interface SilhouetteBlueStage {
          selected: any[];
          uniforms: {
            color: Cesium.Color;
            length: number;
          };
        }

        interface PickedFeatureMovement {
          position: Cesium.Cartesian2;
        }

        handler.setInputAction(
          (movement: PickedFeatureMovement) => {
            const silhouetteBlue = scene.postProcessStages.get(0) as SilhouetteBlueStage;
            silhouetteBlue.selected = [];
            const pickedFeature: any = scene.pick(movement.position);
            if (silhouetteBlue.selected[0] === pickedFeature) {
              return;
            }
            silhouetteBlue.selected = [pickedFeature];
          },
          ScreenSpaceEventType.LEFT_CLICK
        );
      } else {
        console.warn('Silhouette for 3d objects is not supported');
      }
    },
    flyTo: (destination: Cesium.Cartesian3, duration: number, orientation = { heading: 0, pitch: 0, roll: 0 }) => {
      scene.camera.flyTo({
        destination,
        duration,
        orientation
      });
    },
    setView: (
      destination: Cesium.Cartesian3,
      orientation: { heading: number; pitch: number; roll: number }
        ) => {
      scene.camera.setView({
        destination,
        orientation
      });
    },
    addSvgIcons: () => {
      const svgIcons = `
      <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <symbol viewBox="0 0 24 24" id="ic_cube_24px">
          <path d="M21,16.5C21,16.88 20.79,17.21 20.47,17.38L12.57,21.82C12.41,21.94 12.21,22 12,22C11.79,22 11.59,21.94 11.43,21.82L3.53,17.38C3.21,17.21 3,16.88 3,16.5V7.5C3,7.12 3.21,6.79 3.53,6.62L11.43,2.18C11.59,2.06 11.79,2 12,2C12.21,2 12.41,2.06 12.57,2.18L20.47,6.62C20.79,6.79 21,7.12 21,7.5V16.5M12,4.15L6.04,7.5L12,10.85L17.96,7.5L12,4.15Z" />
        </symbol>
        <symbol viewBox="0 0 24 24" id="ic_clock-time-four_24px">
          <path d="M12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C17.5 22 22 17.5 22 12S17.5 2 12 2M16.3 15.2L11 12.3V7H12.5V11.4L17 13.9L16.3 15.2Z" />
        </symbol>
          <svg viewBox="0 0 24 24" id="ic_box-shadow_24px"><path d="M3,3H18V18H3V3M19,19H21V21H19V19M19,16H21V18H19V16M19,13H21V15H19V13M19,10H21V12H19V10M19,7H21V9H19V7M16,19H18V21H16V19M13,19H15V21H13V19M10,19H12V21H10V19M7,19H9V21H7V19Z" />
        </symbol>
      </svg>
      `;
      const div = document.createElement('div');
      div.innerHTML = svgIcons;
      document.body.insertBefore(div, document.body.childNodes[0]);
    },
    addStreetView:() => {
      const streetViewHtml = `
        <div id="streetView" style="
          position: absolute;
          bottom: 165px;
          left: 17px;
          z-index: 100;
          cursor: pointer;
          background: rgba(255, 255, 255, 0.7);
          border-radius: 4px;
          padding: 3px;
          display: flex;
          align-items: center;
          gap: 8px;
        ">

          <div id="" style="
            border: 1px solid #424242;
            border-radius: 4px;
            display: flex;
          ">
            <div id="street-mode-toggle" style=" padding-top: 2px;">
              <svg width="26" height="26" viewBox="0 0 24 24" fill="gray" xmlns="http://www.w3.org/2000/svg">
                <path d="M15 4.5C15 5.88071 13.8807 7 12.5 7C11.1193 7 10 5.88071 10 4.5C10 3.11929 11.1193 2 12.5 2C13.8807 2 15 3.11929 15 4.5Z" fill="hsl(0, 0%, 29%)"/>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9292 9.2672C11.129 9.25637 11.3217 9.25 11.5 9.25C12.0541 9.25 12.6539 9.31158 13.1938 9.38913C14.7154 9.60766 15.8674 10.7305 16.3278 12.1117C16.4321 12.4245 16.7484 12.6149 17.0737 12.5607L18.8767 12.2602C19.2853 12.1921 19.6717 12.4681 19.7398 12.8767C19.8079 13.2853 19.5319 13.6717 19.1233 13.7398L17.3203 14.0403C16.2669 14.2159 15.2425 13.599 14.9048 12.586C14.5975 11.6642 13.862 11.0005 12.9806 10.8739C12.7129 10.8354 12.4404 10.8029 12.1757 10.7809L11.9045 13.4923C11.8206 14.332 11.8108 14.5537 11.8675 14.7518C11.9241 14.9498 12.0497 15.1328 12.5652 15.8009L16.9942 21.5419C17.2473 21.8698 17.1865 22.3408 16.8585 22.5938C16.5306 22.8468 16.0596 22.7861 15.8066 22.4581L11.3775 16.7172C11.3536 16.6862 11.33 16.6556 11.3066 16.6254C10.896 16.0941 10.5711 15.6738 10.4253 15.1645C10.2796 14.6551 10.3329 14.1265 10.4004 13.4585C10.4042 13.4205 10.4081 13.382 10.412 13.3431L10.6661 10.8023C8.99274 11.076 7.75003 12.6491 7.75003 14.5C7.75003 14.9142 7.41424 15.25 7.00003 15.25C6.58581 15.25 6.25003 14.9142 6.25003 14.5C6.25003 11.8593 8.16383 9.41707 10.9292 9.2672ZM10.1471 16.7646C10.5533 16.8458 10.8167 17.2409 10.7355 17.6471C10.3779 19.4349 9.4014 21.0394 7.97772 22.1783L7.46855 22.5857C7.1451 22.8444 6.67313 22.792 6.41438 22.4685C6.15562 22.1451 6.20806 21.6731 6.53151 21.4143L7.04067 21.007C8.18877 20.0885 8.97625 18.7946 9.26459 17.3529C9.34583 16.9467 9.74094 16.6833 10.1471 16.7646Z" fill="hsl(0, 0%, 29%)"/>
              </svg>
            </div>
            <div id="height-controls" style="
              display: none;
              flex-direction: row;
              align-items: center;
              justify-content: center;
              border-left: 1px solid;
              padding: 2px;
              font-family: sans-serif;
              font-size: 14px;
              color: hsl(0, 0%, 29%);
            ">
              <div style="padding-left: 3px; padding-right: 3px;">
                <div id="height-up" style="margin-bottom: -3px; color: hsl(0, 0%, 29%);">▲</div>
                <div id="height-down" style="margin-top: -3px; color: hsl(0, 0%, 29%);">▼</div>
              </div>
              <div id="height-display">${cameraHeight.toFixed(2)} m</div>
            </div>
          </div>
        </div>
      `;
      const div = document.createElement('div');
      div.innerHTML = streetViewHtml;
      document.body.insertBefore(div, document.body.childNodes[0]);
    },
    addControls: () => {
      const cameraControlHtml = `
        <div id="controlUI" style="
          position: absolute;
          bottom: 75px;
          left: 17px;
          z-index: 99;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
          font-size: 1rem;
          font-weight: 400;
          line-height: 1.5;
          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
          box-sizing: border-box;
          background: rgba(255, 255, 255, 0.7);
          border-radius: 4px;
          display: inline-block;
          padding: 3px;
        ">
          <div id="camera-controls" style="
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #424242;
            border-radius: 4px;
            color: #424242;
          ">
            <button id="cam-up" style="margin-bottom: -16px; background: none; border: none; cursor: pointer; padding: 4px;">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="hsl(0, 0%, 29%)" style="transform: rotate(-90deg);">
                <use xlink:href="#ic_chevron_right_24px"></use>
              </svg>
            </button>
            <div style="display: flex; gap: 8px;">
              <button id="cam-left" style="background: none; border: none; cursor: pointer; padding: 4px;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="hsl(0, 0%, 29%)" style="transform: rotate(180deg);">
                  <use xlink:href="#ic_chevron_right_24px"></use>
                </svg>
              </button>
              <button id="cam-right" style="background: none; border: none; cursor: pointer; padding: 4px;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="hsl(0, 0%, 29%)">
                  <use xlink:href="#ic_chevron_right_24px"></use>
                </svg>
              </button>
            </div>
            <button id="cam-down" style="margin-top: -16px; background: none; border: none; cursor: pointer; padding: 4px;">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="hsl(0, 0%, 29%)" style="transform: rotate(90deg);">
                <use xlink:href="#ic_chevron_right_24px"></use>
              </svg>
            </button>
          </div>
        </div>
      `;
      const div = document.createElement('div');
      div.innerHTML = cameraControlHtml;
      document.body.insertBefore(div, document.body.childNodes[0]);
    }
  };

  // 3D assets
  const assets = {
    // Terrain providers
    terrainProviders: async () => {
      if (cesiumTerrainProvider) {
        terrain = await CesiumTerrainProvider.fromUrl(cesiumTerrainProvider, {
          requestVertexNormals: true
          // Add as option for 3D Tiles request
          // requestWaterMask: true,
        });
        scene.terrainProvider = terrain;
      } else if (cesiumIonassetIdTerrain && cesiumIontoken) {
        terrain = await CesiumTerrainProvider.fromUrl(IonResource.fromAssetId(cesiumIonassetIdTerrain), {
          requestVertexNormals: true
          // Add as option for 3D Tiles request
          // requestWaterMask: true,
        });
        scene.terrainProvider = terrain;
      } else if (cesiumIontoken) {
        // Cesium world terrain is used as default if token is present
        terrain = await createWorldTerrainAsync({
          requestVertexNormals: true
        });
        scene.terrainProvider = terrain;
      }
    },
    // Cesium 3D Tile providers
    cesium3DtilesProviders: () => {
      add3DTile(scene, map, cesiumIontoken);
    },
    // GLTF providers
    gltfProviders: () => {
      if (gltf) {
        gltf.forEach((gltfAsset) => {
          const url = gltfAsset.url;
          const lat = gltfAsset.lat;
          const lng = gltfAsset.lng;
          const height = gltfAsset.height;
          const heightReference = gltfAsset.heightReference;
          const animation = gltfAsset.animation;
          addGLTF(scene, url, lat, lng, height, heightReference, animation);
        });
      }
    }
  };

  const cesiumSettings = {
    // Configure options for Scene
    scene: () => {
      // @ts-ignore: Ignore error if scene.clock is not writable
      scene.clock = new Clock();
      // Enables/disables atmosphere
      if (scene.skyAtmosphere) {
        scene.skyAtmosphere.show = !!settings.enableAtmosphere;
      }
      // Enables fog/disables
      scene.fog.enabled = !!settings.enableFog;
      // Shadow settings
      const shadowSettings = settings.shadows;
      const shadowMap = scene.shadowMap;
      shadowMap.darkness = shadowSettings.darkness || false;
      shadowMap.fadingEnabled = !!shadowSettings.fadingEnabled;
      shadowMap.maximumDistance = shadowSettings.maximumDistance || false;
      shadowMap.normalOffset = !!shadowSettings.normalOffset;
      shadowMap.size = shadowSettings.size || false;
      shadowMap.softShadows = !!shadowSettings.softShadows;

      var viewModel = {
        ambientOcclusionOnly: false,
        intensity: 0.5,
        bias: 0.1,
        lengthCap: 100,
        stepSize: 10.0,
        blurStepSize: 2,
      };
      const ambientOcclusion = scene.postProcessStages.ambientOcclusion;
      ambientOcclusion.enabled = true;

      ambientOcclusion.uniforms.ambientOcclusionOnly = Boolean(
        viewModel.ambientOcclusionOnly
      );
      ambientOcclusion.uniforms.intensity = Number(viewModel.intensity);
      ambientOcclusion.uniforms.bias = Number(viewModel.bias);
      ambientOcclusion.uniforms.lengthCap = (viewModel.lengthCap);
      ambientOcclusion.uniforms.stepSize = Number(viewModel.stepSize);
      ambientOcclusion.uniforms.blurStepSize = Number(viewModel.blurStepSize);
    },
    // Configure options for Globe
    globe: () => {
      const globe = scene.globe;
      // Enables/disables depthTestAgainstTerrain
      globe.depthTestAgainstTerrain = !!settings.depthTestAgainstTerrain;
      // Enables/disables enableGroundAtmosphere
      // globe.enableGroundAtmosphere = !!settings.showGroundAtmosphere;
      // Options to set different skyboxes
      if (settings.skyBox) {
        const url = settings.skyBox.url;
        scene.skyBox = new SkyBox({
          sources: {
            positiveX: `${url}${settings.skyBox.images.pX}`,
            negativeX: `${url}${settings.skyBox.images.nX}`,
            positiveY: `${url}${settings.skyBox.images.pY}`,
            negativeY: `${url}${settings.skyBox.images.nY}`,
            positiveZ: `${url}${settings.skyBox.images.pZ}`,
            negativeZ: `${url}${settings.skyBox.images.nZ}`
          }
        });
      }
      settings.skyBox = false;
    }
  };

  return Origo.ui.Component({
    name: 'globe',
    onAdd(evt: { target: any }) {
      viewer = evt.target;
      if (!target) target = `${viewer.getMain().getNavigation().getId()}`;
      oGlobeTarget = viewer.getId();
      map = viewer.getMap();
      featureInfo = viewer.getControlByName('featureInfo');
      // Init flatpickr to set the datetime in oGlobe.time
      helpers.timeSetter();
      // Init OLCesium
      oGlobe = new window.OLCesium({
        map,
        target: oGlobeTarget,
        time(): Cesium.JulianDate {
          return JulianDate.fromDate(new Date((fp.element as HTMLInputElement).value));
        }
      });
      // OLCesium needs to be global
      window.oGlobe = oGlobe;
      // Gets Scene
      scene = oGlobe.getCesiumScene();
      // setResolutionScale as configuration option
      oGlobe.setResolutionScale(resolutionScale);

      // scene.requestRender();
      // Call the helpers
      helpers.addStreetView();
      helpers.addControls();
      helpers.addSvgIcons();
      helpers.showGlobeOption();
      helpers.cesiumCredits();
      helpers.setActiveControls(oGlobe, viewer);
      helpers.pickedFeatureStyle();
      // Call the settings
      Object.values(cesiumSettings).forEach((cesiumSetting: () => void) => cesiumSetting());
      // Call the assets
      Object.values(assets).forEach((asset: () => void) => asset());
      // Infowindow i globe mode
      getFeatureInfo(scene, viewer, map, featureInfo, helpers.flyTo);

      const canvas: HTMLCanvasElement = scene.canvas;
      const camera: Cesium.Camera = scene.camera;
      const controller: Cesium.ScreenSpaceCameraController = scene.screenSpaceCameraController;
      const handler: Cesium.ScreenSpaceEventHandler = new ScreenSpaceEventHandler(scene.canvas);
      // Cesium.RequestScheduler.maximumRequests = 1;
      let pickedEntity: Cesium.PointPrimitive | undefined;
      let cartesian: Cesium.Cartesian3 | undefined;
      let position1: Cesium.Cartesian3 | null = null;
      let position2: Cesium.Cartesian3 | null = null;
      let sensorShadowInstance: SensorShadow | null;
      let redBall: Cesium.PointPrimitive | null;
      let pointPrimitiveCollection: Cesium.PointPrimitiveCollection | null;
      
      scene.globe.maximumScreenSpaceError = 4/3

      const observer: MutationObserver = new MutationObserver(() => {
      const viewShedToggleBtn = document.getElementById(viewshedButton.getId());
      if (viewShedToggleBtn) {
        viewShedToggleBtn.onclick = () => {
        if (isViewShed) {
          isViewShed = false;
          position1 = null;
          position2 = null;
          scene.globe.shadows = Cesium.ShadowMode.DISABLED;

          if (pointPrimitiveCollection) {
          scene.primitives.remove(pointPrimitiveCollection);
          pointPrimitiveCollection = null;
          redBall = null;
          }

          if (sensorShadowInstance && !sensorShadowInstance.isDestroyed()) {
          sensorShadowInstance.destroy();
          sensorShadowInstance = null;
          }

          alert('Viewshed-läge avstängt.');
          document.removeEventListener('click', handleClick as EventListener, true);
          return;
        }

        scene.globe.shadows = Cesium.ShadowMode.ENABLED;
        isViewShed = true;
        alert('Klicka på kartan för att placera startpunkten. Klicka igen för att placera slutpunkten.');

      
        document.addEventListener('click', handleClick as EventListener, true);
        };
      };
      });

      observer.observe(document.body, { childList: true, subtree: true });

      function handleClick(event: MouseEvent) {
      if (isViewShed) {
        const { left, top } = canvas.getBoundingClientRect();
        const x = event.clientX - left;
        const y = event.clientY - top;
        const position = scene.pickPosition(new Cesium.Cartesian3(x, y));
        const carto = Cesium.Cartographic.fromCartesian(position);
        carto.height += cameraHeight;

        if (position) {
        if (position1 === null) {
          position1 = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height);
        } else if (position2 === null) {
          position2 = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height);

          document.removeEventListener('click', handleClick as EventListener, true);
          enterViewShed();
        }
        } else {
        alert('Kan inte starta viewshed här.');
        }
      }
      }

      function enterViewShed(): void {
      pointPrimitiveCollection = new Cesium.PointPrimitiveCollection();
      redBall = pointPrimitiveCollection.add({
        position: position1!,
        pixelSize: 10,
        color: Cesium.Color.BLUE,
      });
      scene.primitives.add(pointPrimitiveCollection);

      sensorShadowInstance = new SensorShadow(scene, {
        cameraPosition: position1!,
        viewPosition: position2!
      });

      handler.setInputAction((click: { position: Cesium.Cartesian2 }) => {
        cartesian = scene.camera.pickEllipsoid(click.position, scene.globe.ellipsoid);
        if (cartesian) {
        const pickedObject = scene.pick(click.position);
        if (Cesium.defined(pickedObject) && pickedObject.id === redBall) {
          pickedEntity = pickedObject.id;
          controller.enableInputs = false;
        }
        }
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      handler.setInputAction((movement: { endPosition: Cesium.Cartesian2 }) => {
        if (pickedEntity) {
        const newCartesian = scene.camera.pickEllipsoid(movement.endPosition, scene.globe.ellipsoid);
        if (newCartesian) {
          const newCartographic = Cesium.Cartographic.fromCartesian(newCartesian);

          const originalCartographic = Cesium.Cartographic.fromCartesian(pickedEntity.position);


          newCartographic.height = originalCartographic.height;

          const updatedCartesian = Cesium.Cartographic.toCartesian(newCartographic);
          pickedEntity.position = updatedCartesian;

          sensorShadowInstance!.cameraPosition = updatedCartesian; // Pass actual Cartesian3
        }
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      handler.setInputAction(() => {
        if (pickedEntity) {
        pickedEntity = undefined;
        controller.enableInputs = true;
        }
      }, Cesium.ScreenSpaceEventType.LEFT_UP);
      }

      const streetViewToggleBtn = document.getElementById('street-mode-toggle') as HTMLElement;
      const heightPanel = document.getElementById('height-controls') as HTMLElement;
      const heightDisplay = document.getElementById('height-display') as HTMLElement;
      const heightUp = document.getElementById('height-up') as HTMLElement;
      const heightDown = document.getElementById('height-down') as HTMLElement;

      streetViewToggleBtn.onclick = () => {
      if (isStreetMode) return exitStreetMode();

      alert('Klicka på kartan för att starta gatuläge\nFör att gå ur, klicka på knappen igen');

      const handleClick = (event: MouseEvent) => {
        document.removeEventListener('click', handleClick as EventListener, true);
        if (event.target !== canvas) {
        heightPanel.style.display = toggleDisplay(heightPanel.style.display);
        return;
        }

        const { left, top } = canvas.getBoundingClientRect();
        const x = event.clientX - left;
        const y = event.clientY - top;
        const position = scene.pickPosition(new Cesium.Cartesian2(x, y));

        if (position) {
        heightPanel.style.display = toggleDisplay(heightPanel.style.display);
        enterStreetMode(position);
        } else {
        alert('Kan inte starta gatuläge här');
        }
      };

      document.addEventListener('click', handleClick as EventListener, true);
      };

      function enterStreetMode(position: Cesium.Cartesian3): void {
      const carto = Cesium.Cartographic.fromCartesian(position);
      carto.height += cameraHeight;

      camera.flyTo({
        destination: Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height),
        orientation: { heading: 0, pitch: 0, roll: 0 }
      });

      Object.assign(controller, {
        enableZoom: false,
        enableWheelZoom: false,
        enablePinchZoom: false,
        enableCollisionDetection: false,
        enableTilt: false,
        enableRotate: false,
        enableLook: false
      });

      canvas.setAttribute("tabindex", "0");
      canvas.onclick = () => canvas.focus();

      streetModePostRenderCallback = scene.postRender.addEventListener(() => {
        if (isCameraAnimating) return;

        const cameraCarto = Cesium.Cartographic.fromCartesian(scene.camera.position);
        const surfaceHeight = scene.globe.getHeight(cameraCarto);
        if (surfaceHeight != null) {
        const desiredHeight = surfaceHeight + cameraHeight;
        if (Math.abs(cameraCarto.height - desiredHeight) > 0.01) {
          cameraCarto.height = desiredHeight;
          scene.camera.position = Cesium.Cartesian3.fromRadians(
          cameraCarto.longitude, cameraCarto.latitude, cameraCarto.height
          );
        }
        }
      });

      // Mouse + keyboard interaction
      // streetModeHandler = new Cesium.ScreenSpaceEventHandler(canvas);

      handler.setInputAction((movement: { position: Cesium.Cartesian2 }) => {
        isDragging = true;
        lastMousePosition = Cesium.Cartesian2.clone(movement.position);
      }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

      handler.setInputAction((movement: { endPosition: Cesium.Cartesian2 }) => {
        if (!isDragging) return;

        const delta = Cesium.Cartesian2.subtract(movement.endPosition, lastMousePosition!, new Cesium.Cartesian2());
        lastMousePosition = Cesium.Cartesian2.clone(movement.endPosition);

        const lookFactor = 0.005;

        // Get current heading and pitch from camera

        let heading = camera.heading;
        let pitch = camera.pitch;

        heading -= delta.x * lookFactor;
        pitch += delta.y * lookFactor;

        // Clamp pitch to prevent flipping
        const maxPitch = Cesium.Math.toRadians(89);
        const minPitch = Cesium.Math.toRadians(-89);
        pitch = Cesium.Math.clamp(pitch, minPitch, maxPitch);

        camera.setView({
        orientation: {
          heading,
          pitch,
          roll: 0.0 // Reset roll to avoid tilting
        }
        });
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);


      handler.setInputAction(() => {
        isDragging = false;
      }, Cesium.ScreenSpaceEventType.LEFT_UP);

      handler.setInputAction((click: { position: Cesium.Cartesian2 }) => {
        const newPos = scene.pickPosition(click.position);
        if (!newPos) {
        alert("Ogiltig position");
        return;
        }

        const newCarto = Cesium.Cartographic.fromCartesian(newPos);
        newCarto.height += cameraHeight;

        isCameraAnimating = true;
        scene.camera.flyTo({
        destination: Cesium.Cartesian3.fromRadians(
          newCarto.longitude,
          newCarto.latitude,
          newCarto.height
        ),
        orientation: {
          heading: scene.camera.heading,
          pitch: 0.0,
          roll: 0.0
        },
        duration: 1.0,
        complete: () => { isCameraAnimating = false; }
        });
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      document.addEventListener('keydown', streetKeyDown as EventListener);
      document.addEventListener('keyup', streetKeyUp as EventListener);

      isStreetMode = true;
      }

      function exitStreetMode(): void {
      isStreetMode = false;
      heightPanel.style.display = toggleDisplay(heightPanel.style.display);

      streetModeHandler?.destroy();
      streetModeHandler = null;

      streetModePostRenderCallback?.();
      streetModePostRenderCallback = null;

      document.removeEventListener('keydown', streetKeyDown as EventListener);
      document.removeEventListener('keyup', streetKeyUp as EventListener);

      const cameraCarto = Cesium.Cartographic.fromCartesian(scene.camera.position);
      const surfaceHeight = scene.globe.getHeight(cameraCarto) || 0;
      const elevatedHeight = surfaceHeight + 70.0;

      scene.camera.flyTo({
        destination: Cesium.Cartesian3.fromRadians(
        cameraCarto.longitude,
        cameraCarto.latitude,
        elevatedHeight
        ),
        orientation: {
        heading: scene.camera.heading,
        pitch: Cesium.Math.toRadians(-15),
        roll: 0.0
        },
        duration: 1.0,
        complete: () => {
        Object.assign(controller, {
          enableZoom: true,
          enableTilt: true,
          enableWheelZoom: true,
          enablePinchZoom: true,
          enableRotate: true,
          enableLook: false,
          enableCollisionDetection: true,
        });
        }
      });
      }

      // Key handler functions
      function streetKeyDown(e: KeyboardEvent): void {
      const flag = keys[e.code as keyof typeof keys];
      if (flag) flags[flag as keyof typeof flags] = true;
      }

      function streetKeyUp(e: KeyboardEvent): void {
      const flag = keys[e.code as keyof typeof keys];
      if (flag) flags[flag as keyof typeof flags] = false;
      }

      function orbitAroundCamera(direction: 'left' | 'right' = 'left', angle: number = Cesium.Math.toRadians(2)): void {
      const sign = direction === 'right' ? 1 : -1;
      camera.setView({
        destination: camera.positionWC,
        orientation: {
        heading: camera.heading + sign * angle,
        pitch: camera.pitch,
        roll: camera.roll
        }
      });
      }

      function orbitAroundCenter(direction: 'left' | 'right' = 'left', baseAngle: number = 0.05): void {
      const screenCenter = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);

      // Try to pick a position on terrain or 3D tiles
      let center = scene.pickPosition(screenCenter);
      if (!Cesium.defined(center)) {
        const ray = camera.getPickRay(screenCenter);
        if (!ray) return;
        const hit = Cesium.IntersectionTests.rayEllipsoid(ray, Cesium.Ellipsoid.WGS84);
        if (!hit) return;
        center = Cesium.Ray.getPoint(ray, hit.start);
      }

      // Get current position and direction
      const cameraPosition = Cesium.Cartesian3.clone(camera.positionWC);
      const directionVector = Cesium.Cartesian3.clone(camera.directionWC);
      const upVector = Cesium.Cartesian3.clone(camera.upWC);

      const angle = direction === 'right' ? baseAngle : -baseAngle;

      // Get local ENU transform
      const enuTransform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
      const inverse = Cesium.Matrix4.inverseTransformation(enuTransform, new Cesium.Matrix4());

      // Convert camera position to local space
      const localPos = Cesium.Matrix4.multiplyByPoint(inverse, cameraPosition, new Cesium.Cartesian3());
      const localDir = Cesium.Matrix4.multiplyByPointAsVector(inverse, directionVector, new Cesium.Cartesian3());
      const localUp = Cesium.Matrix4.multiplyByPointAsVector(inverse, upVector, new Cesium.Cartesian3());

      // Rotate around local Z (up)
      const rotMatrix = Cesium.Matrix3.fromRotationZ(angle);
      const rotatedPos = Cesium.Matrix3.multiplyByVector(rotMatrix, localPos, new Cesium.Cartesian3());
      const rotatedDir = Cesium.Matrix3.multiplyByVector(rotMatrix, localDir, new Cesium.Cartesian3());
      const rotatedUp = Cesium.Matrix3.multiplyByVector(rotMatrix, localUp, new Cesium.Cartesian3());
      const newPos = Cesium.Matrix4.multiplyByPoint(enuTransform, rotatedPos, new Cesium.Cartesian3());
      const newDir = Cesium.Matrix4.multiplyByPointAsVector(enuTransform, rotatedDir, new Cesium.Cartesian3());
      const newUp = Cesium.Matrix4.multiplyByPointAsVector(enuTransform, rotatedUp, new Cesium.Cartesian3());

      camera.setView({
        destination: newPos,
        orientation: {
        direction: Cesium.Cartesian3.normalize(newDir, new Cesium.Cartesian3()),
        up: Cesium.Cartesian3.normalize(newUp, new Cesium.Cartesian3()),
        },
      });
      }

      // Camera movement buttons
      (document.getElementById('cam-up') as HTMLElement).onclick = () => camera.lookUp(Cesium.Math.toRadians(3));
      (document.getElementById('cam-down') as HTMLElement).onclick = () => camera.lookDown(Cesium.Math.toRadians(3));

      (document.getElementById('cam-left') as HTMLElement).onclick = () => {
      isStreetMode ? orbitAroundCamera('left') : orbitAroundCenter('left');
      };

      (document.getElementById('cam-right') as HTMLElement).onclick = () => {
      isStreetMode ? orbitAroundCamera('right') : orbitAroundCenter('right');
      };

      // Height controls
      const updateHeightDisplay = (): void => {
      heightDisplay.textContent = `${cameraHeight.toFixed(2)} m`;
      };

      heightUp.onclick = () => {
      cameraHeight = Math.min(cameraHeight + 0.05, 9999);
      updateHeightDisplay();
      };

      heightDown.onclick = () => {
      cameraHeight = Math.max(cameraHeight - 0.05, 1);
      updateHeightDisplay();
      };

      function toggleDisplay(current: string): string {
      return current === 'flex' ? 'none' : 'flex';
      }

      this.on('render', this.onRender as () => void);
      this.addComponents(buttons);
      this.render();
    },
    onInit() {
      globeEl = Origo.ui.Element({
        tagName: 'div',
        cls: 'flex column z-index-ontop-top-times20'
      });

      globeButton = Origo.ui.Button({
        cls: 'o-globe padding-small margin-bottom-smaller icon-smaller round light box-shadow',
        click() {
          toggleGlobe();
          toggleButtons();
          helpers.setActiveControls(oGlobe, viewer);
        },
        icon: '#ic_cube_24px',
        tooltipText: 'Globe',
        tooltipPlacement: 'east'
      });
      buttons.push(globeButton);

      flatpickrButton = Origo.ui.Button({
        cls: 'padding-small margin-bottom-smaller icon-smaller round light box-shadow hidden',
        click() {
          const el = document.getElementById(flatpickrButton.getId());
          if (el) {
            const active = el.classList.toggle('active');
            active ? fp.open() : fp.close();
          }
        },
        icon: '#ic_clock-time-four_24px',
        tooltipText: 'Datetime picker',
        tooltipPlacement: 'east'
      });
      buttons.push(flatpickrButton);

      viewshedButton = Origo.ui.Button({
        cls: 'padding-small margin-bottom-smaller icon-smaller round light box-shadow',
        click() {
          const el = document.getElementById(viewshedButton.getId());
          if (el) {
            el.classList.toggle('active');
          }
        },
        icon: '#ic_visibility_24px',
        tooltipText: 'Viewshed analysis',
        tooltipPlacement: 'east'
      });
      buttons.push(viewshedButton);

      const quickTimeContainer = document.createElement('div');
      quickTimeContainer.classList.add('quick-time-container', 'origo-popup', 'animate');
      quickTimeContainer.style.display = 'none';
      quickTimeContainer.style.position = 'absolute';
      quickTimeContainer.style.zIndex = '9999';
      quickTimeContainer.style.padding = '10px';
      quickTimeContainer.style.background = '#fff';
      quickTimeContainer.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
      quickTimeContainer.style.borderRadius = '6px';
      document.body.appendChild(quickTimeContainer);

      // Fill it with the time buttons
      const predefinedTimes = [
        { date: '2025-03-20', label: '20 Mars' },
        { date: '2025-06-21', label: '21 Juni' },
        { date: '2025-09-22', label: '22 September' },
        { date: '2025-09-23', label: '23 September' },
        { date: '2025-12-21', label: '21 December' }
      ];
      const hours = [9, 12, 16];

      predefinedTimes.forEach((dateObj) => {
        const dateLabel = document.createElement('div');
        dateLabel.innerText = dateObj.label;
        dateLabel.style.fontWeight = 'bold';
        quickTimeContainer.appendChild(dateLabel);

        hours.forEach((hour) => {
          const btn = document.createElement('button');
          btn.innerText = `${hour}:00`;
          btn.classList.add('quick-time-button', 'small');
          btn.style.marginRight = '4px';
          btn.addEventListener('click', () => {
            const selectedDate = new Date(dateObj.date);
            selectedDate.setHours(hour, 0, 0);
            fp.setDate(selectedDate, true);
            quickTimeContainer.style.display = 'none'; // Hide after click
          });
          quickTimeContainer.appendChild(btn);
        });

        const spacer = document.createElement('div');
        spacer.style.marginBottom = '10px';
        quickTimeContainer.appendChild(spacer);
      });

      quickTimePickerButton = Origo.ui.Button({
        cls: 'padding-small margin-bottom-smaller icon-smaller round light box-shadow quick-time-button',
        click() {
          const isVisible = quickTimeContainer.style.display === 'block';
          quickTimeContainer.style.display = isVisible ? 'none' : 'block';
          console.log(isVisible);
      
          if (!isVisible) {
            const btnEl = document.getElementById(quickTimePickerButton.getId());
            if (btnEl) {
              const rect = btnEl.getBoundingClientRect();
              quickTimeContainer.style.left = `${rect.right + 10}px`;
              quickTimeContainer.style.top = `${rect.top}px`;
            }
          }
        },
        icon: '#ic_clock-time-four_24px',
        tooltipText: 'Snabbval för tid',
        tooltipPlacement: 'east'
      });
      buttons.push(quickTimePickerButton);

      toggleShadowsButton = Origo.ui.Button({
        cls: 'padding-small margin-bottom-smaller icon-smaller round light box-shadow active',
        click() {
          const el = document.getElementById(toggleShadowsButton.getId());
          if (el) {
            const active = el.classList.toggle('active');
            scene.shadowMap.enabled = active;
          } else {
            // Optionally handle the case when el is null
            console.warn('toggleShadowsButton element not found');
          }
        },
        icon: '#ic_box-shadow_24px',
        tooltipText: 'Toggle shadows',
        tooltipPlacement: 'east'
      });
      buttons.push(toggleShadowsButton);

      toggleFXButton = Origo.ui.Button({
        cls: 'padding-small margin-bottom-smaller icon-smaller round light box-shadow active',
        click() {
          const el = document.getElementById(toggleFXButton.getId());
          if (el) {
            const active = el.classList.toggle('active');
            scene.fog.enabled = active && !!settings.enableFog;
            const shadowMap = scene.shadowMap;
            const shadowSettings = settings.shadows;
            shadowMap.fadingEnabled = active ? shadowSettings.fadingEnabled : false;
            shadowMap.normalOffset = active ? shadowSettings.normalOffset : false;
            shadowMap.size = active ? shadowSettings.size : 1024;
            shadowMap.softShadows = active ? shadowSettings.softShadows : false;
            scene.postProcessStages.ambientOcclusion.enabled = active;
          }
        },
        icon: '#ic_cube_24px',
        tooltipText: 'Toggle FX Settings',
        tooltipPlacement: 'east'
      });
      buttons.push(toggleFXButton);
    },
    render() {

      const globeElDomTar = document.getElementById(target ?? '');
      if(globeElDomTar) {
        htmlString = `${globeEl.render()}`;
        el = Origo.ui.dom.html(htmlString);
        globeElDomTar.appendChild(el);
      }

      const globeElDom = document.getElementById(globeEl.getId());
      if (globeElDom) {

        htmlString = globeButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);

        htmlString = flatpickrButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);

        htmlString = quickTimePickerButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);

        htmlString = viewshedButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);

        htmlString = toggleShadowsButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);

        htmlString = toggleFXButton.render();
        el = Origo.ui.dom.html(htmlString);
        globeElDom.appendChild(el);
      }

      helpers.activeGlobeOnStart();
      this.dispatch('render');
      scene.shadowMap.enabled = true

    },
    isGlobeActive() {
      return isGlobeActive(oGlobe);
    },
    threedtiletype() {
      return threedtile;
    },
    gltftype() {
      return addGLTF;
    },
    globalOLCesium() {
      return OLCesium
    }
  });
};